## 3. 라이브러리 활용

### 3-1. C++ 표준 라이브러리
### 문자열 관련 함수

str.length() -> 문자열의 길이를 구해줌 <br>
str.size() -> 해당 객체가 차지하는 메모리의 크기를 반환함 **(C++에서는 '\0' 문자가 붙지 않는다. C언어의 경우에는 '\0' 문자가 붙는다.)** <br>
str.empty() -> 문자열이 비었는지 아닌지를 검사<br>
str.append(추가할 문자열) -> 문자열의 끝에 새로운 문자열을 추가<br>
str.find(str) -> 원하는 문자열의 시작 위치를 알려준다. 찾지 못한다면, **string::npos ; (-1) 라는 상수**를 반환한다.<br>
str.compare(비교할 문자열) -> 문자열을 비교할 때 사용 <br>
str.replace(size_t pos, size_t len, const string &str) -> 문자열의 교체<br>
**(C++11)** std::wstring -> 유니코드 문자에 대해 상황에 따라서 적절한 데이터 형식과 인코딩을 선택해야 했던 기존의 문제점 해결

### 파일 시스템
fstream : 해당 파일의 내용을 읽어내는 역할을 수행하나, 파일 이름이나 위치 같은 파일에 대한 메타 데이터의 수정은 불가능 <br>
파일 시스템 : 파일에 대한 접근이 가능하나, 파일 자체를 읽을 수는 없다. **C++17** 에서 파일 시스템 라이브러리를 지원하게 되었으며, <filesystem> 헤더를 포함하여 사용할 수 있음

해당 경로에 파일이 실재로 존재하는지 보려면 exists 함수를 사용해야 한다

~~~
bool exists(const std::filesystem::path& p)
~~~

기존의 boost::filesystem은 사용하려는 시스템에 맞게 컴파일된 라이브러리가 필요하며, std::filesystem의 경우도 C++17 이상의 컴파일러만 사용 가능하다

**C++17/20 으로 빋드**하기 위해서는 다음과 같이 해야 한다
~~~
g++ -std=c++17(20) file_system.cpp -o file_system
~~~

### 기타 유용한 함수
1. 난수 생성 :
- C/C++의 rand 함수는 난수 생성 패턴이 하나, srand는 난수 생성 패턴이 여러 개이다.<br>
- **C++11**부터는 **\<random\> 헤더 파일**을 사용한 고품질의 난수 생성기와 분포 클래스를 제공해준다.
- 시각을 이용한 시드 값을 사용 함으로써 실행할 때마다 완전히 다른 값을 만들 수 있다.
- **random_device** 클래스를 통헤 하드웨어 엔트로피를 이용해 난수를 생성할 수 있다.

2. 수학 함수 :
- \<cmath\> 헤더 파일을 사용한다.
- numbers::pi의 경우 **C++20**부터 사용 가능하다.

### 3-2. STL의 컨테이너, 알고리즘